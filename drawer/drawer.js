import menuApi from './menuApi.js';
import { LinkedListMap } from './LinkedListMap.js';
const canvasWidth = 1024, canvasHeight = 768;
const selectorRectSize = 10;
class Point2D {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}
class AbstractShape {
    constructor() {
        this.borderColor = 'black';
        this.backgroundColor = null;
        this.id = AbstractShape.counter++;
    }
    // Draw selector rectangle
    drawSelectRect(ctx, point, color) {
        const selectFrom = this.validPoint(point.x - selectorRectSize / 2, point.y - selectorRectSize / 2);
        const selectTo = this.validPoint(point.x + selectorRectSize / 2, point.y + selectorRectSize / 2);
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.strokeRect(selectFrom.x, selectFrom.y, selectTo.x - selectFrom.x, selectTo.y - selectFrom.y);
        ctx.stroke();
    }
    validPoint(x, y) {
        if (x < 0) {
            x = 0;
        }
        else if (x > canvasWidth) {
            x = canvasWidth;
        }
        if (y < 0) {
            y = 0;
        }
        else if (y > canvasHeight) {
            y = canvasHeight;
        }
        return new Point2D(x, y);
    }
    setBorderColor(color) {
        this.borderColor = color;
    }
    setBackgroundColor(color) {
        this.backgroundColor = color;
    }
    doStyle(ctx) {
        // Set the border color
        ctx.strokeStyle = this.borderColor;
        // Set the fill color if available, otherwise use transparent
        if (this.backgroundColor) {
            ctx.fillStyle = this.backgroundColor;
        }
        else {
            ctx.fillStyle = 'transparent';
        }
    }
    equals(other) {
        return this.id === other.id;
    }
}
AbstractShape.counter = 0;
class AbstractFactory {
    constructor(shapeManager) {
        this.shapeManager = shapeManager;
    }
    handleMouseDown(x, y) {
        this.from = new Point2D(x, y);
    }
    handleMouseUp(x, y) {
        // remove the temp line, if there was one
        if (this.tmpShape) {
            this.shapeManager.removeShapeWithId(this.tmpShape.id, false);
        }
        this.shapeManager.addShape(this.createShape(this.from, new Point2D(x, y)));
        this.from = undefined;
    }
    handleMouseMove(x, y) {
        // show temp circle only, if the start point is defined;
        if (!this.from) {
            return;
        }
        if (!this.tmpTo || (this.tmpTo.x !== x || this.tmpTo.y !== y)) {
            this.tmpTo = new Point2D(x, y);
            if (this.tmpShape) {
                // remove the old temp line, if there was one
                this.shapeManager.removeShapeWithId(this.tmpShape.id, false);
            }
            // adds a new temp line
            this.tmpShape = this.createShape(this.from, new Point2D(x, y));
            this.shapeManager.addShape(this.tmpShape);
        }
    }
}
class Line extends AbstractShape {
    constructor(from, to) {
        super();
        this.from = from;
        this.to = to;
    }
    draw(ctx, selected, color) {
        super.doStyle(ctx);
        ctx.beginPath();
        ctx.moveTo(this.from.x, this.from.y);
        ctx.lineTo(this.to.x, this.to.y);
        ctx.stroke();
        if (selected) {
            this.drawSelectRect(ctx, this.from, color);
            this.drawSelectRect(ctx, this.to, color);
        }
    }
    //Generated by ChatGPT
    pointInShape(p, margin = 5) {
        // Calculate the perpendicular distance from the point to the line
        const dist = this.pointToLineDistance(p);
        // Check if the point is within the margin of the line
        if (dist <= margin) {
            // Check if the point is within the bounds of the line segment
            if (this.isPointOnLineSegment(p)) {
                return true;
            }
        }
        return false;
    }
    //Generated by ChatGPT
    pointToLineDistance(p) {
        // Calculate the distance from point p to the line defined by 'from' and 'to'
        const numerator = Math.abs((this.to.y - this.from.y) * p.x - (this.to.x - this.from.x) * p.y + this.to.x * this.from.y - this.to.y * this.from.x);
        const denominator = Math.sqrt(Math.pow(this.to.y - this.from.y, 2) + Math.pow(this.to.x - this.from.x, 2));
        return numerator / denominator;
    }
    //Generated by ChatGPT
    isPointOnLineSegment(p) {
        // Check if the point p is within the bounds of the line segment (from, to)
        const minX = Math.min(this.from.x, this.to.x);
        const maxX = Math.max(this.from.x, this.to.x);
        const minY = Math.min(this.from.y, this.to.y);
        const maxY = Math.max(this.from.y, this.to.y);
        return p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY;
    }
}
class LineFactory extends AbstractFactory {
    constructor(shapeManager) {
        super(shapeManager);
        this.label = "Linie";
    }
    createShape(from, to) {
        return new Line(from, to);
    }
}
class Circle extends AbstractShape {
    constructor(center, radius) {
        super();
        this.center = center;
        this.radius = radius;
    }
    draw(ctx, selected, color) {
        super.doStyle(ctx);
        ctx.beginPath();
        ctx.arc(this.center.x, this.center.y, this.radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
        if (selected) {
            this.drawSelectRect(ctx, this.center, color);
        }
    }
    //Generated by ChatGPT
    pointInShape(p) {
        const dx = p.x - this.center.x;
        const dy = p.y - this.center.y;
        const distanceSquared = dx * dx + dy * dy;
        return distanceSquared <= this.radius * this.radius;
    }
}
class CircleFactory extends AbstractFactory {
    constructor(shapeManager) {
        super(shapeManager);
        this.label = "Kreis";
    }
    createShape(from, to) {
        return new Circle(from, CircleFactory.computeRadius(from, to.x, to.y));
    }
    static computeRadius(from, x, y) {
        const xDiff = (from.x - x), yDiff = (from.y - y);
        return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
    }
}
class Rectangle extends AbstractShape {
    constructor(from, to) {
        super();
        this.from = from;
        this.to = to;
    }
    draw(ctx, selected, color) {
        super.doStyle(ctx);
        ctx.beginPath();
        ctx.fillRect(this.from.x, this.from.y, this.to.x - this.from.x, this.to.y - this.from.y);
        ctx.strokeRect(this.from.x, this.from.y, this.to.x - this.from.x, this.to.y - this.from.y);
        ctx.stroke();
        if (selected) {
            this.drawSelectRect(ctx, this.from, color);
            this.drawSelectRect(ctx, this.to, color);
            this.drawSelectRect(ctx, new Point2D(this.from.x, this.to.y), color);
            this.drawSelectRect(ctx, new Point2D(this.to.x, this.from.y), color);
        }
    }
    //Generated by ChatGPT
    pointInShape(p) {
        // Check if the point (p) is within the bounds of the rectangle
        return p.x >= this.from.x && p.x <= this.to.x && p.y >= this.from.y && p.y <= this.to.y;
    }
}
class RectangleFactory extends AbstractFactory {
    constructor(shapeManager) {
        super(shapeManager);
        this.label = "Rechteck";
    }
    createShape(from, to) {
        return new Rectangle(from, to);
    }
}
class Triangle extends AbstractShape {
    constructor(p1, p2, p3) {
        super();
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
    }
    draw(ctx, selected, color) {
        super.doStyle(ctx);
        ctx.beginPath();
        ctx.moveTo(this.p1.x, this.p1.y);
        ctx.lineTo(this.p2.x, this.p2.y);
        ctx.lineTo(this.p3.x, this.p3.y);
        ctx.lineTo(this.p1.x, this.p1.y);
        ctx.fill();
        ctx.stroke();
        if (selected) {
            this.drawSelectRect(ctx, this.p1, color);
            this.drawSelectRect(ctx, this.p2, color);
            this.drawSelectRect(ctx, this.p3, color);
        }
    }
    //Generated by ChatGPT
    pointInShape(p) {
        // Area of the full triangle
        const areaOrig = this.triangleArea(this.p1, this.p2, this.p3);
        // Areas of the sub-triangles formed with the point
        const area1 = this.triangleArea(p, this.p2, this.p3);
        const area2 = this.triangleArea(this.p1, p, this.p3);
        const area3 = this.triangleArea(this.p1, this.p2, p);
        // If the sum of the areas of the sub-triangles is equal to the area of the original triangle, the point is inside
        return (areaOrig === area1 + area2 + area3);
    }
    //Generated by ChatGPT
    // Helper function to calculate the area of a triangle using the determinant method
    triangleArea(p1, p2, p3) {
        return Math.abs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2);
    }
}
class TriangleFactory {
    constructor(shapeManager) {
        this.shapeManager = shapeManager;
        this.label = "Dreieck";
    }
    handleMouseDown(x, y) {
        if (this.tmpShape) {
            this.shapeManager.removeShapeWithId(this.tmpShape.id, false);
            this.shapeManager.addShape(new Triangle(this.from, this.tmpTo, new Point2D(x, y)));
            this.from = undefined;
            this.tmpTo = undefined;
            this.tmpLine = undefined;
            this.thirdPoint = undefined;
            this.tmpShape = undefined;
        }
        else {
            this.from = new Point2D(x, y);
        }
    }
    handleMouseUp(x, y) {
        // remove the temp line, if there was one
        if (this.tmpLine) {
            this.shapeManager.removeShapeWithId(this.tmpLine.id, false);
            this.tmpLine = undefined;
            this.tmpTo = new Point2D(x, y);
            this.thirdPoint = new Point2D(x, y);
            this.tmpShape = new Triangle(this.from, this.tmpTo, this.thirdPoint);
            this.shapeManager.addShape(this.tmpShape);
        }
    }
    handleMouseMove(x, y) {
        // show temp circle only, if the start point is defined;
        if (!this.from) {
            return;
        }
        if (this.tmpShape) { // second point already defined, update temp triangle
            if (!this.thirdPoint || (this.thirdPoint.x !== x || this.thirdPoint.y !== y)) {
                this.thirdPoint = new Point2D(x, y);
                if (this.tmpShape) {
                    // remove the old temp line, if there was one
                    this.shapeManager.removeShapeWithId(this.tmpShape.id, false);
                }
                // adds a new temp triangle
                this.tmpShape = new Triangle(this.from, this.tmpTo, this.thirdPoint);
                this.shapeManager.addShape(this.tmpShape);
            }
        }
        else { // no second point fixed, update tmp line
            if (!this.tmpTo || (this.tmpTo.x !== x || this.tmpTo.y !== y)) {
                this.tmpTo = new Point2D(x, y);
                if (this.tmpLine) {
                    // remove the old temp line, if there was one
                    this.shapeManager.removeShapeWithId(this.tmpLine.id, false);
                }
                // adds a new temp line
                this.tmpLine = new Line(this.from, this.tmpTo);
                this.shapeManager.addShape(this.tmpLine);
            }
        }
    }
}
// class Shapes {
// }
class SelectTool {
    constructor(shapeManager) {
        this.shapeManager = shapeManager;
        this.label = "Select";
        // State for Alt-based cycling
        this.altShapes = [];
        this.altIndex = -1;
        this.altCycleActive = false;
        // Modifier flags
        this.altPressed = false;
        this.ctrlPressed = false;
        // Track Alt and Ctrl key state
        window.addEventListener("keydown", (e) => {
            if (e.key === "Alt")
                this.altPressed = true;
            if (e.key === "Control")
                this.ctrlPressed = true;
        });
        window.addEventListener("keyup", (e) => {
            if (e.key === "Alt") {
                this.altPressed = false;
                // End any Alt-based cycle
                this.altCycleActive = false;
                this.altShapes = [];
                this.altIndex = -1;
            }
            if (e.key === "Control")
                this.ctrlPressed = false;
        });
    }
    handleMouseDown(x, y) {
        const ids = this.shapeManager.getShapeIdsAtPoint(x, y);
        var selected_shape = -1;
        var additive = false;
        if (ids.length > 0) {
            selected_shape = ids[0];
        }
        // Ctrl: additive selection, toggles each click
        if (this.ctrlPressed) {
            // Add or remove this shape without clearing others
            additive = true;
        }
        // Alt: cycling through shapes that where under cursor at first click 
        if (this.altPressed) {
            if (!this.altCycleActive) {
                // First Alt-click: capture list and start cycle
                this.altShapes = ids;
                this.altIndex = 0;
                this.altCycleActive = true;
            }
            else {
                // Subsequent Alt-clicks: advance index
                this.altIndex = (this.altIndex + 1) % this.altShapes.length;
            }
            selected_shape = this.altShapes[this.altIndex];
        }
        this.shapeManager.selectShapeById(selected_shape, additive);
    }
    handleMouseUp(_x, _y) { }
    handleMouseMove(_x, _y) { }
}
class ToolArea {
    constructor(shapesSelector, menue) {
        this.selectedShape = undefined;
        const domElms = [];
        shapesSelector.forEach(sl => {
            const domSelElement = document.createElement("li");
            domSelElement.innerText = sl.label;
            menue.appendChild(domSelElement);
            domElms.push(domSelElement);
            domSelElement.addEventListener("click", () => {
                selectFactory.call(this, sl, domSelElement);
            });
        });
        function selectFactory(sl, domElm) {
            // remove class from all elements
            for (let j = 0; j < domElms.length; j++) {
                domElms[j].classList.remove("marked");
            }
            this.selectedShape = sl;
            // add class to the one that is selected currently
            domElm.classList.add("marked");
        }
    }
    getSelectedShape() {
        return this.selectedShape;
    }
}
class Canvas {
    constructor(canvasDomElement, toolarea) {
        this.shapes = new LinkedListMap();
        this.selectedShapes = new Set();
        this.ctx = canvasDomElement.getContext("2d");
        canvasDomElement.addEventListener("mousemove", createMouseHandler("handleMouseMove"));
        canvasDomElement.addEventListener("mousedown", createMouseHandler("handleMouseDown"));
        canvasDomElement.addEventListener("mouseup", createMouseHandler("handleMouseUp"));
        function createMouseHandler(methodName) {
            return function (e) {
                e = e || window.event;
                if ('object' === typeof e) {
                    const btnCode = e.button, x = e.pageX - this.offsetLeft, y = e.pageY - this.offsetTop, ss = toolarea.getSelectedShape();
                    // if left mouse button is pressed,
                    // and if a tool is selected, do something
                    if (e.button === 0 && ss) {
                        const m = ss[methodName];
                        // This in the shapeFactory should be the factory itself.
                        m.call(ss, x, y);
                    }
                }
            };
        }
    }
    draw() {
        this.ctx.beginPath();
        this.ctx.fillStyle = 'lightgrey';
        this.ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        this.ctx.stroke();
        for (const shape of this.shapes) {
            const isSelected = this.selectedShapes.has(shape);
            shape.draw(this.ctx, isSelected, 'red');
        }
        return this;
    }
    addShape(shape, redraw = true) {
        this.shapes.add(shape.id, shape);
        return redraw ? this.draw() : this;
    }
    removeShape(shape, redraw = true) {
        this.shapes.removeById(shape.id);
        this.selectedShapes.delete(shape);
        return redraw ? this.draw() : this;
    }
    removeShapeWithId(id, redraw = true) {
        // Remove the shape from the main shape list
        this.shapes.removeById(id);
        // Remove the shape from the selected shapes set, if present
        for (const shape of this.selectedShapes) {
            if (shape.id === id) {
                this.selectedShapes.delete(shape);
                break;
            }
        }
        return redraw ? this.draw() : this;
    }
    getShapeIdsAtPoint(x, y) {
        const pt = new Point2D(x, y);
        const result = [];
        for (const shape of this.shapes) {
            if (shape.pointInShape(pt)) {
                result.push(shape.id);
            }
        }
        // Sort ascending by ID for consistency
        return result.sort((a, b) => a - b);
    }
    selectShapeById(id, additive = false) {
        if (!additive) {
            this.selectedShapes.clear();
        }
        const shape = this.shapes.getById(id);
        if (this.selectedShapes.has(shape)) {
            this.selectedShapes.delete(shape); // Deselect if already selected
        }
        else if (shape) {
            this.selectedShapes.add(shape);
        }
        this.draw();
    }
    getSelectedShapes() {
        return Array.from(this.selectedShapes);
    }
    /**
     * Moves all selected shapes to the front (top of z-order).
     * First element in the list is back, last is front.
     */
    bringSelectedToFront(redraw = true) {
        // We move each selected shape in turn
        for (const shape of this.selectedShapes) {
            this.shapes.moveToBack(shape.id);
        }
        return redraw ? this.draw() : this;
    }
    /**
     * Moves all selected shapes to the back (bottom of z-order).
     */
    sendSelectedToBack(redraw = true) {
        for (const shape of this.selectedShapes) {
            this.shapes.moveToFront(shape.id);
        }
        return redraw ? this.draw() : this;
    }
}
export function init() {
    const canvasDomElm = document.getElementById("drawArea");
    const menu = document.getElementsByClassName("tools");
    // Problem here: Factories needs a way to create new Shapes, so they
    // have to call a method of the canvas.
    // The canvas on the other side wants to call the event methods
    // on the toolbar, because the toolbar knows what tool is currently
    // selected.
    // Anyway, we do not want the two to have references on each other
    let canvas;
    const sm = {
        addShape(s, rd) {
            return canvas.addShape(s, rd);
        },
        removeShape(s, rd) {
            return canvas.removeShape(s, rd);
        },
        removeShapeWithId(id, rd) {
            return canvas.removeShapeWithId(id, rd);
        },
        getShapeIdsAtPoint(x, y) {
            return canvas.getShapeIdsAtPoint(x, y);
        },
        selectShapeById(id, additive) {
            return canvas.selectShapeById(id, additive);
        },
        getSelectedShapes() {
            return canvas.getSelectedShapes();
        },
        bringSelectedToFront(redraw) {
            return canvas.bringSelectedToFront(redraw);
        },
        sendSelectedToBack(redraw) {
            return canvas.sendSelectedToBack(redraw);
        }
    };
    const shapesSelector = [
        new LineFactory(sm),
        new CircleFactory(sm),
        new RectangleFactory(sm),
        new TriangleFactory(sm),
        new SelectTool(sm)
    ];
    const toolArea = new ToolArea(shapesSelector, menu[0]);
    canvas = new Canvas(canvasDomElm, toolArea);
    canvas.draw();
    // -------------------------
    // Popup menu integration
    // -------------------------
    const contextMenu = menuApi.createMenu();
    // DELETE option
    contextMenu.addItem(menuApi.createItem('Delete Selected', () => {
        const shapes = sm.getSelectedShapes();
        shapes.forEach(shape => sm.removeShape(shape, false));
        canvas.draw();
        contextMenu.hide();
    }));
    contextMenu.addItem(menuApi.createSeparator());
    // Border Color option
    contextMenu.addItem(menuApi.createRadioOption("Rahmenfarbe", { black: "Black", red: "Red", green: "Green", yellow: "Yellow", blue: "Blue" }, "black", key => {
        const selectedShapes = sm.getSelectedShapes();
        selectedShapes.forEach(shape => shape.setBorderColor(key));
        canvas.draw();
    }));
    // Background Color option
    contextMenu.addItem(menuApi.createRadioOption("Hintergrundfarbe", { transparent: "Transparent", black: "Black", red: "Red", green: "Green", yellow: "Yellow", blue: "Blue" }, "white", key => {
        const selectedShapes = sm.getSelectedShapes();
        selectedShapes.forEach(shape => shape.setBackgroundColor(key));
        canvas.draw();
    }));
    contextMenu.addItem(menuApi.createSeparator());
    // Bring to Front
    contextMenu.addItem(menuApi.createItem("Bring to Front", () => {
        sm.bringSelectedToFront();
    }));
    // Send to Back
    contextMenu.addItem(menuApi.createItem("Send to Back", () => {
        sm.sendSelectedToBack();
    }));
    // show it on right-click over the canvas
    canvasDomElm.addEventListener("contextmenu", e => {
        e.preventDefault();
        const rect = canvasDomElm.getBoundingClientRect();
        contextMenu.show(e.clientX - rect.left, e.clientY - rect.top);
    });
}
init();
//# sourceMappingURL=drawer.js.map